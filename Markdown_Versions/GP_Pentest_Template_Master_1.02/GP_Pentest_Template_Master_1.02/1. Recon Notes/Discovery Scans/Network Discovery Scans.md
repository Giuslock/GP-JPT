# NetDiscover (ARP Scanning):
- netdiscover -i eth0
- netdiscover -r 172.21.10.0/24

# Dsniff Arpspoof

First enable Linux box to act as a router:

`echo 1 > /proc/sys/net/ipv4/ip_forward`

Then run `arpspoof`:

`arpspoof -i <interface> -t <target> -r <host>`

For example, to intercept traffic between targets, use:

`arpspoof -i eth0 -t 192.168.4.11 -r 192.168.4.16`

# Nmap:

- nmap -sn 172.21.10.0/24
- nmap -sn 172.21.10.1-253
- nmap -sn 172.21.10.*

You can also grep out the IPs and cut out fluf:
```
nmap -sn 172.x.x.x/24 | grep "172" | cut -f 5 -d ' '
```

A slower, more stealthier approach that utilizes the files containing the IP address split (as seen in the first section above) would be:
```
nmap --randomize-hosts -sn -T2 -oN nmap_discoveryScan_x.x.x.x-16.txt -iL x.x.x.x_IP_range.split.txt
```
This will export the results into a text file (`-oN`). Randomized hosts is optional, depending on the customer and the testing situation. The flag, `-oA`, can be used in place of `-oX` or `-oN`, as `-oA` will output the results to all output formats. 

The results for both command options shown above will be the list of hosts that responded to the ping, thus are up and alive.

# Nbtscan: 
- nbtscan -r 172.21.1.0/24

# Masscan
- masscan 172.21.10.0/24 --ping

# Ping Sweeps

## Linux Ping Sweep (Bash)

- for i in {1..254} ;do (ping -c 1 172.21.10.$i | grep "bytes from" &) ;done

## Windows Ping Sweep (Run on Windows System)

- for /L %i in (1,1,255) do @ping -n 1 -w 200 172.21.10.%i > nul && echo 172.21.1.%i is up.

## Powershell Ping Sweep: 
Note: This command can also run on powershell for Linux

- 1..20 | % {"172.21.10.$($_): $(Test-Connection -count 1 -comp 172.21.10.$($_) -quiet)"}
- Get-PingSweep Subnet 172.21.10
```
# Reference: https://gist.github.com/joegasper/93ff8ae44fa8712747d85aa92c2b4c78
function ResolveIp($IpAddress) {
    try {
        (Resolve-DnsName $IpAddress -QuickTimeout -ErrorAction SilentlyContinue).NameHost
    } catch {
        $null
    }
}

function Invoke-PingSweep {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true)]
        [string]$SubNet,
        [switch]$ResolveName
    )
    $ips = 1..254 | ForEach-Object {"$($SubNet).$_"}
    $ps = foreach ($ip in $ips) {
        (New-Object Net.NetworkInformation.Ping).SendPingAsync($ip, 250)
        #[Net.NetworkInformation.Ping]::New().SendPingAsync($ip, 250) # or if on PowerShell v5
    }
    [Threading.Tasks.Task]::WaitAll($ps)
    $ps.Result | Where-Object -FilterScript {$_.Status -eq 'Success' -and $_.Address -like "$subnet*"} 
    Select-Object Address,Status,RoundtripTime -Unique |
    ForEach-Object {
        if ($_.Status -eq 'Success') {
            if (!$ResolveName) {
                $_
            } else {
                $_ | Select-Object Address, @{Expression={ResolveIp($_.Address)};Label='Name'}, Status, RoundtripTime
            }
        }
    }
}
```

## Python Ping Sweep:

The following python script can be used to perform a ping scan. 
```
#!/usr/bin/env python3
import ipaddress
from subprocess import Popen, DEVNULL

for ping in range(1, 254):
        address = "x.x.x.%d" % ping
        response = Popen(["ping", "-c1", address], stdout=DEVNULL)
        output = response.communicate()[0]
        val1 = response.returncode
        if val1 == 0:
                print(address)
```
This script is specifically used for a /24 network. Modification required for other network types. 