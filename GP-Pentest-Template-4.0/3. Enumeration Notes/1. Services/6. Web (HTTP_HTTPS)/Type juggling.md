### strcmp()/strcasecmp()

If this function is used for **any authentication check** (like checking the password) and the user controls one side of the comparison, he can send an empty array instead of a string as the value of the password (`https://example.com/login.php/?username=admin&password[]=`) and bypass this check:

```
if (!strcmp("real_pwd","real_pwd")) { echo 

"Real Password"; } else { echo 

"No Real Password"; }
// Real Password
if (!strcmp(array(),"real_pwd")) { echo 

"Real Password"; } else { echo 

"No Real Password"; }
// Real Password
```

The same error occurs with `strcasecmp()`

### Strict type Juggling

Even if `===` is **being used** there could be errors that makes the **comparison vulnerable** to **type juggling**. For example, if the comparison is **converting the data to a different type of object before comparing**:

```
(int) "1abc" 

=== (int) "1xyz" 

//This will be true
```

### preg\_match(/^.\*/)

`preg_match()` could be used to **validate user input** (it **checks** if any **word/regex** from a **blacklist** is **present** on the **user input** and if it's not, the code can continue it's execution).

#### New line bypass

However, when delimiting the start of the regexp`preg_match()` **only checks the first line of the user input**, then if somehow you can **send** the input in **several lines**, you could be able to bypass this check. Example:

```
$myinput="aaaaaaa
11111111"; //Notice the new line
echo 

preg_match("/1/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo 

preg_match("/1.*$/",$myinput);
//1  --> In this scenario preg_match find the char "1"
echo 

preg_match("/^.*1/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
echo 

preg_match("/^.*1.*$/",$myinput);
//0  --> In this scenario preg_match DOESN'T find the char "1"
```